<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/06/11/hello-world/"/>
    <url>/2020/06/11/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>了解数据结构和算法</title>
    <link href="/2020/05/30/Java/%E4%BA%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    <url>/2020/05/30/Java/%E4%BA%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/05/30/5aXjmqI1koKygnt.png" srcset="/img/loading.gif" alt="image.png"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>编程好比是一辆汽车，而数据结构和算法是汽车内部的变速箱。一个开车的人不懂变速箱的原理也是能开车的，同理一个不懂数据结构和算法的人也能编程。但是如果一个开车的人懂变速箱的原理，比如降低速度来获得更大的牵引力，或者通过降低牵引力来获得更快的行驶速度。那么爬坡时使用1档，便可以获得更大的牵引力；下坡时便使用低档限制车的行驶速度。</p><p>回到编程而言，比如将一个班级的学生名字要临时存储在内存中，你会选择什么数据结构来存储，数组还是ArrayList，或者HashSet，或者别的数据结构。如果不懂数据结构的，可能随便选择一个容器来存储，也能完成所有的功能，但是后期如果随着学生数据量的增多，随便选择的数据结构肯定会存在性能问题，而一个懂数据结构和算法在实际编程中会选择适当的数据结构来解决相应的问题，会极大的提高程序的性能。</p><p>拿一个厨师的厨艺来比较的话，<strong>真正的大厨一般不是那种能做各种花样的菜式的人，而是能把普通的菜炒出不平凡的效果的人。</strong>就像“酸辣土豆丝”，不同的人炒出来的效果就不一样，从一道简单的菜就可以看出厨师的功底，而数据结构与算法就是程序员的功底。</p><p>由图中可以看出，数据结构操组的对象是数据元素，即他们有相同的属性（属性也取决于观察者的角度），它们之间的存在的关系会产生不同的结构，数据元素之间的关系+操作构成了数据类型，对已有的数据类型进行抽象就构成了抽象数据类型（ADT），就是封装了值和操作的模型。</p></blockquote><h1 id="一-数据结构"><a href="#一-数据结构" class="headerlink" title="一.数据结构"></a>一.数据结构</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h2><p><strong>数据结构</strong>：互相之间<strong>有一种或多种关系的数据元素</strong>的集合。</p><ul><li>通常情况下，精心选择的数据结构可以带来<strong>更高的运行或者存储效率</strong>。数据结构往往同<strong>高效的检索算法和索引技术</strong>有关。</li></ul><ul><li><p>数据结构分为<strong>逻辑结构</strong>和<strong>存储结构</strong></p><ul><li><p>逻辑结构：反映了各数据间的逻辑关系的数据结构，即前<strong>后件的关系，如：早餐和午餐的关系。</strong></p></li><li><p>存储结构：又称<strong>物理结构</strong>，是数据的<strong>逻辑结构在计算机中存储空间的存放的方式</strong>。</p></li></ul></li><li><p>数据结构的表示：数据的<strong>逻辑结构</strong>的数学形式定义——数据结构是一个二元组。</p><blockquote><p>​                                                        B=(D,R)</p><p>B:数据结构                              D:数据元素的集合                      R：集合D上面的关系</p><p>例：                                               </p><p>​                                                         B=(D,R)</p><p>​                                             D：{早餐，午餐，晚餐}</p><p>​                                             R：{（早餐，午餐），（午餐，晚餐）}</p></blockquote></li></ul><h2 id="2-线性结构和非线性结构"><a href="#2-线性结构和非线性结构" class="headerlink" title="2.线性结构和非线性结构"></a>2.线性结构和非线性结构</h2><p> 结构又分为<strong>线性结构</strong> 和<strong>非线性结构</strong></p><ul><li><p>节点：1.根节点：数据结构中没有前件的节点。</p><p>​            2.终端节点(叶子节点)：没有后件的节点。</p><p>​            3.内部节点：除了根节点和叶子节点以外的节点。</p></li></ul><p><strong>线性结构</strong>：惯称<strong>线性表</strong>，常见的线性表有<strong>数组，链表，栈(stack)，队列,链表</strong>等。</p><ul><li>有且只有一个根节点</li><li>每个节点最多有一个前件和后后件。</li></ul><p><strong>非线性结构</strong>：</p><ul><li>不满足以上两个条件。如<strong>树形，网状</strong>等。</li></ul><h2 id="2-数据结构的基本功能"><a href="#2-数据结构的基本功能" class="headerlink" title="2.数据结构的基本功能"></a>2.数据结构的基本功能</h2><p>①、如何插入一条新的数优点</p><p>②、如何寻找某一特定的数据项</p><p>③、如何删除某一特定的数据项</p><p>④、如何迭代的访问各个数据项，以便进行显示或其他操作</p><h2 id="3-常见的数据结构"><a href="#3-常见的数据结构" class="headerlink" title="3.常见的数据结构"></a>3.常见的数据结构</h2><p><img src="https://i.loli.net/2020/05/30/DjXx65fQczRkW4S.png" srcset="/img/loading.gif" alt="image.png"></p><p><strong>有序数组的查找时间复杂度时O(lgn),无序数组的时间复杂度是O（N），但是对于插入操作，有序数组的时间复杂度是O(n)，因为他需要把比插入数大的都往后移，无序数组插入的时间复杂度为O(1)。</strong></p><table><thead><tr><th>数据结构</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>无序数组</td><td>插入快</td><td>查找慢，删除慢，大小固定，只能存储单一元素</td></tr><tr><td>有序数组</td><td>比无序数组查询块</td><td>插入慢，删除慢，大小固定，只能存储单一元素</td></tr><tr><td>栈</td><td>提供后进先出的存储方式</td><td>存取其他项很慢</td></tr><tr><td>队列</td><td>提供先进先出的存储方式</td><td>存取其他项很慢</td></tr><tr><td>链表</td><td>插入快，删除快</td><td>查找慢</td></tr><tr><td>二叉树</td><td><strong>如果树是平衡的</strong>，则查找，删除，插入都快</td><td>删除算法复杂</td></tr><tr><td>红黑树</td><td>树<strong>总是平衡</strong>的算法结构，则查找，删除，插入都快</td><td>算法复杂</td></tr><tr><td>2-3-4树</td><td>树<strong>总是平衡</strong>的算法结构，则查找，删除，插入都快。类似的树对磁盘的存储有效</td><td>算法复杂</td></tr><tr><td>哈希表</td><td>如果关键字已知则存取极快</td><td>删除慢，如果不知道关键字存取慢，对存储空间使用不充分</td></tr><tr><td>堆</td><td>插入，删除快，对最大数据项存取快</td><td>对其他数据项存取慢</td></tr><tr><td>图</td><td>对现实世界建模</td><td>有些算法慢且复杂</td></tr></tbody></table><h1 id="二-算法"><a href="#二-算法" class="headerlink" title="二.算法"></a>二.算法</h1><h2 id="1-算法的五个特征"><a href="#1-算法的五个特征" class="headerlink" title="1.算法的五个特征"></a>1.算法的五个特征</h2><ul><li><strong>有穷性</strong>：对于任意一组合法输入值，在执行又穷步骤之后一定能结束，即：<strong>算法中的每个步骤都能在有限时间内完成。</strong></li><li><strong>可行性</strong>：算法中的所有操作都必须足够基本，都可以通过已经实现的基本操作运算有限次实现之。即：<strong>保证每一步都可以执行。</strong></li><li><strong>确定性</strong>:在每种情况下所应执行的操作，在算法中都有确切的规定，使算法的执行者或阅读者都能明确其含义及如何执行。并且在任何条件下，算法都只有一条执行路径。即：<strong>要有明确的含义，不摸棱两可。</strong></li><li><strong>输入</strong>：作为算法加工对象的量值，通常体现在算法当中的一组变量。有些输入量需要在算法执行的过程中输入，而有的算法表面上可以没有输入，实际上已被嵌入算法之中。</li><li><strong>输出：</strong>它是一组与“输入”有确定关系的量值，是算法进行信息加工后得到的结果，这种确定关系即为算法功能。</li></ul><h2 id="2-算法的设计原则"><a href="#2-算法的设计原则" class="headerlink" title="2.算法的设计原则"></a>2.算法的设计原则</h2><p>①、<strong>正确性</strong>：首先，算法应当满足以特定的<strong>规则说明</strong>方式给出的需求。其次，对算法是否<strong>正确</strong>的理解可以有以下四个层次：</p><p>  一、程序语法错误。</p><p>  二、程序对于几组输入数据能够得出满足需要的结果。</p><p>  三、程序对于精心选择的、典型、苛刻切带有刁难性的几组输入数据能够得出满足要求的结果。</p><p>  四、程序对于一切合法的输入数据都能得到满足要求的结果。</p><p>  <strong>PS：通常以第 三 层意义的正确性作为衡量一个算法是否合格的标准。</strong></p><p>②、<strong>可读性</strong>：算法为了人的阅读与交流，其次才是计算机执行。因此算法应该易于人的理解；另一方面，晦涩难懂的程序易于隐藏较多的错误而难以调试。</p><p>③、<strong>健壮性</strong>：当输入的数据非法时，算法应当恰当的做出反应或进行相应处理，而不是产生莫名其妙的输出结果。并且，处理出错的方法不应是中断程序执行，而是应当返回一个表示错误或错误性质的值，以便在更高的抽象层次上进行处理。</p><p>④、<strong>高效率与低存储量需求</strong>：通常算法效率值得是算法执行时间；存储量是指算法执行过程中所需要的最大存储空间，两者都与问题的规模有关。</p><p>前面三点 <strong>正确性，可读性和健壮性</strong>相信都好理解。对于第四点算法的执行效率和存储量，我们知道比较算法的时候，可能会说“A算法比B算法快两倍”之类的话，但实际上这种说法没有任何意义。因为当数据项个数发生变化时，A算法和B算法的效率比例也会发生变化，比如数据项增加了50%，可能A算法比B算法快三倍，但是如果数据项减少了50%，可能A算法和B算法速度一样。所以描述算法的速度必须要和数据项的个数联系起来。也就是“大O”表示法，它是一种算法复杂度的相对表示方式，这里我简单介绍一下，后面会根据具体的算法来描述。</p><p><strong>相对(relative)：</strong>你只能比较相同的事物。你不能把一个做算数乘法的算法和排序整数列表的算法进行比较。但是，比较2个算法所做的算术操作（一个做乘法，一个做加法）将会告诉你一些有意义的东西；</p><p><strong>表示(representation)：</strong>大O(用它最简单的形式)把算法间的比较简化为了一个单一变量。这个变量的选择基于观察或假设。例如，排序算法之间的对比通常是基于比较操作(比较2个结点来决定这2个结点的相对顺序)。这里面就假设了比较操作的计算开销很大。但是，如果比较操作的计算开销不大，而交换操作的计算开销很大，又会怎么样呢？这就改变了先前的比较方式；</p><p><strong>复杂度(complexity)：</strong>如果排序10,000个元素花费了我1秒，那么排序1百万个元素会花多少时间？在这个例子里，复杂度就是相对其他东西的度量结果。</p><p>然后我们在说说算法的存储量，包括：</p><p><strong>程序本身所占空间；</strong></p><p><strong>输入数据所占空间；</strong></p><p><strong>辅助变量所占空间；</strong></p><p>一个算法的效率越高越好，而存储量是越低越好。</p><h2 id="3-算法的复杂程度"><a href="#3-算法的复杂程度" class="headerlink" title="3.算法的复杂程度"></a>3.算法的复杂程度</h2><ul><li><strong>时间复杂度</strong>：指执行算法所计算的工作量，而不是执行时间的长短。（<strong>算法的工作量是算法所执行基本运算的次数来度量的</strong>）</li></ul><p>​     <strong>O():大O记法</strong>：O(1)，O(n)，O(n^2)，O(n^3)，O(logn)等</p><p>​     常见的时间复杂度的比较：O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt;   O(n^n)</p><p>​          <strong>S(n)=O(f(n))</strong>:n为问题的规模，f(n)为语句关于n所占存储空间的函数。</p><ul><li><strong>空间复杂度</strong>：指执行算法所需要的内存空间。（减少输入数据所占的内存空间及额外空间，通常采用压缩存储技术）</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>了解数据结构和算法</title>
    <link href="/2020/05/30/c%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    <url>/2020/05/30/c%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/05/30/5aXjmqI1koKygnt.png" srcset="/img/loading.gif" alt="image.png"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>编程好比是一辆汽车，而数据结构和算法是汽车内部的变速箱。一个开车的人不懂变速箱的原理也是能开车的，同理一个不懂数据结构和算法的人也能编程。但是如果一个开车的人懂变速箱的原理，比如降低速度来获得更大的牵引力，或者通过降低牵引力来获得更快的行驶速度。那么爬坡时使用1档，便可以获得更大的牵引力；下坡时便使用低档限制车的行驶速度。</p><p>回到编程而言，比如将一个班级的学生名字要临时存储在内存中，你会选择什么数据结构来存储，数组还是ArrayList，或者HashSet，或者别的数据结构。如果不懂数据结构的，可能随便选择一个容器来存储，也能完成所有的功能，但是后期如果随着学生数据量的增多，随便选择的数据结构肯定会存在性能问题，而一个懂数据结构和算法在实际编程中会选择适当的数据结构来解决相应的问题，会极大的提高程序的性能。</p><p>拿一个厨师的厨艺来比较的话，<strong>真正的大厨一般不是那种能做各种花样的菜式的人，而是能把普通的菜炒出不平凡的效果的人。</strong>就像“酸辣土豆丝”，不同的人炒出来的效果就不一样，从一道简单的菜就可以看出厨师的功底，而数据结构与算法就是程序员的功底。</p><p>由图中可以看出，数据结构操组的对象是数据元素，即他们有相同的属性（属性也取决于观察者的角度），它们之间的存在的关系会产生不同的结构，数据元素之间的关系+操作构成了数据类型，对已有的数据类型进行抽象就构成了抽象数据类型（ADT），就是封装了值和操作的模型。</p></blockquote><h1 id="一-数据结构"><a href="#一-数据结构" class="headerlink" title="一.数据结构"></a>一.数据结构</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h2><p><strong>数据结构</strong>：互相之间<strong>有一种或多种关系的数据元素</strong>的集合。</p><ul><li>通常情况下，精心选择的数据结构可以带来<strong>更高的运行或者存储效率</strong>。数据结构往往同<strong>高效的检索算法和索引技术</strong>有关。</li></ul><ul><li><p>数据结构分为<strong>逻辑结构</strong>和<strong>存储结构</strong></p><ul><li><p>逻辑结构：反映了各数据间的逻辑关系的数据结构，即前<strong>后件的关系，如：早餐和午餐的关系。</strong></p></li><li><p>存储结构：又称<strong>物理结构</strong>，是数据的<strong>逻辑结构在计算机中存储空间的存放的方式</strong>。</p></li></ul></li><li><p>数据结构的表示：数据的<strong>逻辑结构</strong>的数学形式定义——数据结构是一个二元组。</p><blockquote><p>​                                                        B=(D,R)</p><p>B:数据结构                              D:数据元素的集合                      R：集合D上面的关系</p><p>例：                                               </p><p>​                                                         B=(D,R)</p><p>​                                             D：{早餐，午餐，晚餐}</p><p>​                                             R：{（早餐，午餐），（午餐，晚餐）}</p></blockquote></li></ul><h2 id="2-线性结构和非线性结构"><a href="#2-线性结构和非线性结构" class="headerlink" title="2.线性结构和非线性结构"></a>2.线性结构和非线性结构</h2><p> 结构又分为<strong>线性结构</strong> 和<strong>非线性结构</strong></p><ul><li><p>节点：1.根节点：数据结构中没有前件的节点。</p><p>​            2.终端节点(叶子节点)：没有后件的节点。</p><p>​            3.内部节点：除了根节点和叶子节点以外的节点。</p></li></ul><p><strong>线性结构</strong>：惯称<strong>线性表</strong>，常见的线性表有<strong>数组，链表，栈(stack)，队列,链表</strong>等。</p><ul><li>有且只有一个根节点</li><li>每个节点最多有一个前件和后后件。</li></ul><p><strong>非线性结构</strong>：</p><ul><li>不满足以上两个条件。如<strong>树形，网状</strong>等。</li></ul><h2 id="2-数据结构的基本功能"><a href="#2-数据结构的基本功能" class="headerlink" title="2.数据结构的基本功能"></a>2.数据结构的基本功能</h2><p>①、如何插入一条新的数优点</p><p>②、如何寻找某一特定的数据项</p><p>③、如何删除某一特定的数据项</p><p>④、如何迭代的访问各个数据项，以便进行显示或其他操作</p><h2 id="3-常见的数据结构"><a href="#3-常见的数据结构" class="headerlink" title="3.常见的数据结构"></a>3.常见的数据结构</h2><p><img src="https://i.loli.net/2020/05/30/DjXx65fQczRkW4S.png" srcset="/img/loading.gif" alt="image.png"></p><p><strong>有序数组的查找时间复杂度时O(lgn),无序数组的时间复杂度是O（N），但是对于插入操作，有序数组的时间复杂度是O(n)，因为他需要把比插入数大的都往后移，无序数组插入的时间复杂度为O(1)。</strong></p><table><thead><tr><th>数据结构</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>无序数组</td><td>插入快</td><td>查找慢，删除慢，大小固定，只能存储单一元素</td></tr><tr><td>有序数组</td><td>比无序数组查询块</td><td>插入慢，删除慢，大小固定，只能存储单一元素</td></tr><tr><td>栈</td><td>提供后进先出的存储方式</td><td>存取其他项很慢</td></tr><tr><td>队列</td><td>提供先进先出的存储方式</td><td>存取其他项很慢</td></tr><tr><td>链表</td><td>插入快，删除快</td><td>查找慢</td></tr><tr><td>二叉树</td><td><strong>如果树是平衡的</strong>，则查找，删除，插入都快</td><td>删除算法复杂</td></tr><tr><td>红黑树</td><td>树<strong>总是平衡</strong>的算法结构，则查找，删除，插入都快</td><td>算法复杂</td></tr><tr><td>2-3-4树</td><td>树<strong>总是平衡</strong>的算法结构，则查找，删除，插入都快。类似的树对磁盘的存储有效</td><td>算法复杂</td></tr><tr><td>哈希表</td><td>如果关键字已知则存取极快</td><td>删除慢，如果不知道关键字存取慢，对存储空间使用不充分</td></tr><tr><td>堆</td><td>插入，删除快，对最大数据项存取快</td><td>对其他数据项存取慢</td></tr><tr><td>图</td><td>对现实世界建模</td><td>有些算法慢且复杂</td></tr></tbody></table><h1 id="二-算法"><a href="#二-算法" class="headerlink" title="二.算法"></a>二.算法</h1><h2 id="1-算法的五个特征"><a href="#1-算法的五个特征" class="headerlink" title="1.算法的五个特征"></a>1.算法的五个特征</h2><ul><li><strong>有穷性</strong>：对于任意一组合法输入值，在执行又穷步骤之后一定能结束，即：<strong>算法中的每个步骤都能在有限时间内完成。</strong></li><li><strong>可行性</strong>：算法中的所有操作都必须足够基本，都可以通过已经实现的基本操作运算有限次实现之。即：<strong>保证每一步都可以执行。</strong></li><li><strong>确定性</strong>:在每种情况下所应执行的操作，在算法中都有确切的规定，使算法的执行者或阅读者都能明确其含义及如何执行。并且在任何条件下，算法都只有一条执行路径。即：<strong>要有明确的含义，不摸棱两可。</strong></li><li><strong>输入</strong>：作为算法加工对象的量值，通常体现在算法当中的一组变量。有些输入量需要在算法执行的过程中输入，而有的算法表面上可以没有输入，实际上已被嵌入算法之中。</li><li><strong>输出：</strong>它是一组与“输入”有确定关系的量值，是算法进行信息加工后得到的结果，这种确定关系即为算法功能。</li></ul><h2 id="2-算法的设计原则"><a href="#2-算法的设计原则" class="headerlink" title="2.算法的设计原则"></a>2.算法的设计原则</h2><p>①、<strong>正确性</strong>：首先，算法应当满足以特定的<strong>规则说明</strong>方式给出的需求。其次，对算法是否<strong>正确</strong>的理解可以有以下四个层次：</p><p>  一、程序语法错误。</p><p>  二、程序对于几组输入数据能够得出满足需要的结果。</p><p>  三、程序对于精心选择的、典型、苛刻切带有刁难性的几组输入数据能够得出满足要求的结果。</p><p>  四、程序对于一切合法的输入数据都能得到满足要求的结果。</p><p>  <strong>PS：通常以第 三 层意义的正确性作为衡量一个算法是否合格的标准。</strong></p><p>②、<strong>可读性</strong>：算法为了人的阅读与交流，其次才是计算机执行。因此算法应该易于人的理解；另一方面，晦涩难懂的程序易于隐藏较多的错误而难以调试。</p><p>③、<strong>健壮性</strong>：当输入的数据非法时，算法应当恰当的做出反应或进行相应处理，而不是产生莫名其妙的输出结果。并且，处理出错的方法不应是中断程序执行，而是应当返回一个表示错误或错误性质的值，以便在更高的抽象层次上进行处理。</p><p>④、<strong>高效率与低存储量需求</strong>：通常算法效率值得是算法执行时间；存储量是指算法执行过程中所需要的最大存储空间，两者都与问题的规模有关。</p><p>前面三点 <strong>正确性，可读性和健壮性</strong>相信都好理解。对于第四点算法的执行效率和存储量，我们知道比较算法的时候，可能会说“A算法比B算法快两倍”之类的话，但实际上这种说法没有任何意义。因为当数据项个数发生变化时，A算法和B算法的效率比例也会发生变化，比如数据项增加了50%，可能A算法比B算法快三倍，但是如果数据项减少了50%，可能A算法和B算法速度一样。所以描述算法的速度必须要和数据项的个数联系起来。也就是“大O”表示法，它是一种算法复杂度的相对表示方式，这里我简单介绍一下，后面会根据具体的算法来描述。</p><p><strong>相对(relative)：</strong>你只能比较相同的事物。你不能把一个做算数乘法的算法和排序整数列表的算法进行比较。但是，比较2个算法所做的算术操作（一个做乘法，一个做加法）将会告诉你一些有意义的东西；</p><p><strong>表示(representation)：</strong>大O(用它最简单的形式)把算法间的比较简化为了一个单一变量。这个变量的选择基于观察或假设。例如，排序算法之间的对比通常是基于比较操作(比较2个结点来决定这2个结点的相对顺序)。这里面就假设了比较操作的计算开销很大。但是，如果比较操作的计算开销不大，而交换操作的计算开销很大，又会怎么样呢？这就改变了先前的比较方式；</p><p><strong>复杂度(complexity)：</strong>如果排序10,000个元素花费了我1秒，那么排序1百万个元素会花多少时间？在这个例子里，复杂度就是相对其他东西的度量结果。</p><p>然后我们在说说算法的存储量，包括：</p><p><strong>程序本身所占空间；</strong></p><p><strong>输入数据所占空间；</strong></p><p><strong>辅助变量所占空间；</strong></p><p>一个算法的效率越高越好，而存储量是越低越好。</p><h2 id="3-算法的复杂程度"><a href="#3-算法的复杂程度" class="headerlink" title="3.算法的复杂程度"></a>3.算法的复杂程度</h2><ul><li><strong>时间复杂度</strong>：指执行算法所计算的工作量，而不是执行时间的长短。（<strong>算法的工作量是算法所执行基本运算的次数来度量的</strong>）</li></ul><p>​     <strong>O():大O记法</strong>：O(1)，O(n)，O(n^2)，O(n^3)，O(logn)等</p><p>​     常见的时间复杂度的比较：O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt;   O(n^n)</p><p>​          <strong>S(n)=O(f(n))</strong>:n为问题的规模，f(n)为语句关于n所占存储空间的函数。</p><ul><li><strong>空间复杂度</strong>：指执行算法所需要的内存空间。（减少输入数据所占的内存空间及额外空间，通常采用压缩存储技术）</li></ul>]]></content>
    
    
    <categories>
      
      <category>c语言数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>注解和反射</title>
    <link href="/2020/05/29/Java/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/"/>
    <url>/2020/05/29/Java/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="一-注解"><a href="#一-注解" class="headerlink" title="一.注解"></a>一.注解</h1><h2 id="1-什么是注解"><a href="#1-什么是注解" class="headerlink" title="1.什么是注解"></a>1.什么是注解</h2><p>◆Annotation是从JDK5.0开始引入的新技术.</p><p>◆Annotation的作用 :</p><p>➢不是程序本身,可以对程序作出解释.(这一-点和注释(comment)没什么区别)</p><p>➢<strong>可以被其他程序(比如:编译器等)读取.</strong></p><p>◆Annotation的格式 :</p><p>➢注解是以<strong>“@注释名”</strong>在代码中存在的,还可以添加一-些参数值,例</p><p>如:@SuppressWarnings(value=”unchecked”). .</p><p>◆Annotation在哪里使用?</p><p>➢可以附加在<strong>package , class , method , field **等上面,相当于给他们添加了额外的辅助信息，我们可以通过</strong>反射机制编程实现**对这些元数据的访问</p><h2 id="2-内置注解"><a href="#2-内置注解" class="headerlink" title="2.内置注解"></a>2.内置注解</h2><p>➢@Override :定义在java.lang.Override中,此注释<strong>只适用于修辞方法</strong>,表示-<strong>一个方法声明打算重写超类中的另一个方法声明</strong>.</p><p>➢@Deprecated :定义在java.lang.Deprecated中,此注释<strong>可以用于修辞方法,属性,类,表示不鼓励程序员使用这样的元素, 通常是因为它很危险或者存在更好的选择.</strong></p><p>➢@SuppressWarnings :定义在java.lang.SuppressWarnings中用来<strong>抑制编译时的警告信息.</strong></p><p>​      与前两个注释有所不同你需要添加一个<strong>参数</strong>才能正确使用，这些参数都是已经定义好了的，我们选择性的使用就好了.</p><ul><li><p>@SuppressWarnings(“all”)</p></li><li><p>@SuppressWarnings(“unchecked”)</p></li><li><p>@SuppressWarnings(value={“unchecked”,”deprecation”})</p></li><li><p>等等….</p></li></ul><h2 id="3-元注解"><a href="#3-元注解" class="headerlink" title="3.元注解"></a>3.元注解</h2><p>◆元注解的作用就是负责注解其他注解, Java定义了4个标准的meta-annotation类型,他们被用来提供对其他annotation类型作说明.</p><p> ◆这些类型和它们所支持的类在java.lang.annotation包中可以找到.</p><p> <strong>( @Target , @Retention，@Documented , @Inherited )</strong><br>          ➢@Target:<strong>用于描述注解的使用范围(即:被描述的注解可以用在什么地方)</strong></p><p>  ➢@Retention :<strong>表示需要在什么级别保存该注释信息,用于描述注解的生命周期</strong></p><p>  ➢<strong>(SOURCE &lt; CLASS &lt; RUNTIME)</strong></p><p>  ➢<strong>@Document</strong>:说明该注解将被包含在javadoc中</p><p>  ➢<strong>@Inherited</strong>: 说明子类可以继承父类中的该注解</p><p>  ➢<strong>@Native</strong>:指定字段是一个常量，其值引用native code。</p><p>  ➢<strong>@Repeatable</strong>注解上可以使用重复注解，即可以在一个地方可以重复使用同一个注解，像spring中的包扫描注解就使用了这个。</p><h2 id="4-自定义注解"><a href="#4-自定义注解" class="headerlink" title="4.自定义注解"></a>4.自定义注解</h2><p>➢使用@interface自定义注解时,自动<strong>继承</strong>了<strong>java.lang. annotation.Annotation</strong>接口</p><p>➢分析:</p><ul><li><p><strong>@ interface</strong>用来声明一个注解,<strong>格式: public @ interface注解名{定义内容}</strong></p></li><li><p>其中的每一一个方法实际 上是声明了一一个配置参数.</p></li><li><p>方法的名称就是参数的名称. ；例如  <strong>int age() ,age就是它的参数名称</strong>  </p></li><li><p>返回值类型就是参数的类型(<strong>返回值只能是基本类型,Class , String , enum</strong> ).</p></li><li><p>可以通过<strong>default</strong>来声明参数的默认值。</p></li><li><p>如果只有一-<strong>个参数成员,一般参数名为value</strong>。</p></li><li><p>注解元素必须要有值, 我们定义注解元素时,经常使用空字符串，0作为默认值。</p></li><li><p>如果没有默认值，我们必须自己手动赋值。</p></li><li><p>如果定义到类中不用写public也可以。</p><pre><code class="hljs Java"><span class="hljs-comment">//自定义注解</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test03</span> </span>&#123;<span class="hljs-comment">//注解可以显示赋值，如果没有默认值， 我们就必须给注解赋值</span><span class="hljs-meta">@MyAnnotation</span>2(age = <span class="hljs-number">18</span>,name = <span class="hljs-string">"吕"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;&#125;    <span class="hljs-meta">@MyAnnotation</span>3(<span class="hljs-string">"吕"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-meta">@Target</span>(&#123;ElementType.TYPE,ElementType.METHOD&#125;)G<span class="hljs-meta">@Retention</span>(RetentionPolicy . RUNTIME)<span class="hljs-meta">@interface</span> MyAnnotation2&#123;<span class="hljs-comment">//注解的参数:参数类型+参数名();</span><span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">age</span><span class="hljs-params">()</span> </span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> -1</span>;<span class="hljs-comment">//如果默认值为-1,代表不存在。</span>String[] schools() <span class="hljs-keyword">default</span> &#123;<span class="hljs-string">"吕"</span>, <span class="hljs-string">"清华大学"</span>&#125;;&#125;<span class="hljs-meta">@Target</span>(&#123;ElementType. TYPE , ElementType .METHOD&#125;)<span class="hljs-meta">@Retention</span>( RetentionPolicy . RUNTIME)<span class="hljs-meta">@interface</span> MyAnnotation3&#123;<span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> </span>;&#125;</code></pre></li></ul><h1 id="二-静态VS动态语言"><a href="#二-静态VS动态语言" class="headerlink" title="二 .静态VS动态语言"></a>二 .静态VS动态语言</h1><h2 id="1-动态语言"><a href="#1-动态语言" class="headerlink" title="1.动态语言"></a>1.动态语言</h2><p>➢是一类在运行时可以改变其结构的语言:例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。</p><p>➢主要动态语言: Object-C、 C#、 JavaScript、 PHP、Python等。</p><h2 id="2-静态语言"><a href="#2-静态语言" class="headerlink" title="2.静态语言"></a>2.静态语言</h2><p>➢与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、 C、C++.</p><p>➢Java不是动态语言，但Java可以称之为“准动态语言”。即Java有一 定的动态性,我们可以利用反射机制获得类似动态语言的特性。Java的动态性让编程的时候更加灵活!</p><h1 id="三-反射机制"><a href="#三-反射机制" class="headerlink" title="三. 反射机制"></a>三. 反射机制</h1><h2 id="1-Java-Reflection"><a href="#1-Java-Reflection" class="headerlink" title="1.Java Reflection"></a>1.Java Reflection</h2><p>➢Reflection (反射)是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</p><p>Class C = Class.forName(jiva.lang.String”)</p><p>➢加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象(<strong>一 个类只有一个Class对象</strong>)，这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个<strong>对象就像一面镜子， 透过这个镜子看到类的结构，所以,我们形象的称之为:反射。</strong></p><blockquote><p>正常方式:引入需 要的”包类”名称一&gt; 通过new实例化取 得实例化对象</p></blockquote><blockquote><p>反射方式:实例化对象一getClass()方法一&gt; 得到完整的“包类”名称</p></blockquote><h2 id="2-Java反射机制研究及应用"><a href="#2-Java反射机制研究及应用" class="headerlink" title="2.Java反射机制研究及应用"></a>2.Java反射机制研究及应用</h2><p>Java反射机制提供的功能</p><p>➢在运行时判断任意-个对象所属的类</p><p>➢在运行时构造任意一个类的对象</p><p>➢在运行时判断任意一个类所具有的成员变量和方法➢在运行时获取泛型信息</p><p>➢在运行时调用任意一个对象的成员变量和方法➢在运行时处理注解</p><p>➢生成动态代理</p><p>➢…</p><h2 id="3-Java反射优点和缺点"><a href="#3-Java反射优点和缺点" class="headerlink" title="3.Java反射优点和缺点"></a>3.Java反射优点和缺点</h2><p>优点:</p><blockquote><p>可以实现动态创建对象和编译，体现出很大的灵活性</p></blockquote><p>缺点:</p><blockquote><p>对性能有影响。使用反射基本上是一-种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于直接执行相同的操作。</p></blockquote><h2 id="4-概念"><a href="#4-概念" class="headerlink" title="4.概念"></a>4.概念</h2><p><img src="https://i.loli.net/2020/05/29/mrN6TbQIjh14BAe.png" srcset="/img/loading.gif" alt="image-20200508173019802.png"></p><ul><li><p>源代码阶段：在硬盘中以.class的方式存储 </p></li><li><p>Class类对象阶段和运行阶段：在内存中存储 </p></li></ul><h2 id="5-Class类"><a href="#5-Class类" class="headerlink" title="5.Class类"></a>5.Class类</h2><p>编写完java文件后，jvm是不能直接运行java文件的，首先要将java文件编译成class文件以后，jvm再把class文件<strong>加载</strong>到内存中，<strong>创建一个Class对象</strong>，这时候才可以使用这个类。加载这个动作，就是由<strong>类加载器</strong>完成的。jRE都为其保留一个不变的Class类型的对象。一个Class对象包含了特定某个结构<strong>(class/interface/enum/annotation/primitive type/void/[])</strong>的有关信息。</p><p>➢Class本身也是一-个类</p><p>➢Class 对象只能由系统建立对象</p><p>➢一个加载的类在JVM中只会有一个Class实例</p><p>➢一个Class对象对应的是一 个加载到JVM中的一个.class文件</p><p>➢每个类的实例都会记得自己是由哪个Class实例所生成</p><p>➢通过Class可以完整地得到一个类中的所有被加载的结构</p><p>➢Class类 是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象</p><p>➢基本的 Java 类型（boolean、byte、char、short、int、long、float 和 double）和关键字 void 也都对应一个 Class 对象。<br>        ➢每个<strong>数组</strong>属于被映射为 Class 对象的一个类，所有具有<strong>相同元素类型和维数的数组</strong>都共享该 Class 对象。</p><p><strong>Class类就是用来描述类的信息的。Class也是一种类型，它专门用来描述类的特征。</strong></p><p><img src="https://i.loli.net/2020/05/29/Eha2dLHwVlnfMUS.png" srcset="/img/loading.gif" alt="image-20200510085958436.png"></p><h2 id="6-获取Class对象的功能"><a href="#6-获取Class对象的功能" class="headerlink" title="6.获取Class对象的功能"></a>6.获取Class对象的功能</h2><p><img src="https://i.loli.net/2020/05/29/TRr3WMPf7k4AhbU.png" srcset="/img/loading.gif" alt="image-20200508174941636.png"></p><table><thead><tr><th align="left">方法名</th><th>功能说明</th></tr></thead><tbody><tr><td align="left">static GlassforName(String name)</td><td>返回指定类名rame的Class对象</td></tr><tr><td align="left">Object newlnstance()</td><td>调用缺省构造函数，返回Class对象的一一个实例</td></tr><tr><td align="left">getName()</td><td>返回此Class对象所表示的实体(类，接口，数组类或void)的名称。</td></tr><tr><td align="left">Class getSuperClass()</td><td>返回当前Class对象的父类的Class对象</td></tr><tr><td align="left">Class[] getInterfaces()</td><td>获取当前Class对象的所有接口</td></tr><tr><td align="left">Class Loader getClassLoader()</td><td>返回该类的类加载器</td></tr><tr><td align="left">Constructor[] getConstructors()</td><td>返回一个包含某些Constructor对象的数组，获取有参构造</td></tr><tr><td align="left">Method getMothed(String name,Class.. T)</td><td>返回一-个Method对象，此对象的形参类型为paramType</td></tr><tr><td align="left">Field[] getDeclaredFields()</td><td>返回Field对象属性的一个数组</td></tr><tr><td align="left">setAccessible</td><td>true:打开权限。</td></tr></tbody></table><h2 id="7-getDeclaredxxx和getxxx的区别"><a href="#7-getDeclaredxxx和getxxx的区别" class="headerlink" title="7.getDeclaredxxx和getxxx的区别"></a>7.getDeclaredxxx和getxxx的区别</h2><blockquote><p>getxxx：此方法获取的是所有public方法级别的xxx。</p></blockquote><blockquote><p>getDeclaredxxx：此方法获得的是自身类的所有xxx。包括公有(public)、私有(private)xxx等，而且不受限于访问权限，但是限定本类(可以访问本身类的xxx或者内部类的xxx)。</p></blockquote><p>例子：</p><ul><li>getMethod():此方法获取的是所有<strong>public方法级别的方法，包括从父类继承的方法</strong>。 </li><li>getDeclaredMethod():此方法获得的是自身类的所有方法，包括<strong>公有(public)、私有(private)方法等，而且不受限于访问权限，但是限定本类(可以访问本身类的方法或者内部类的方法)</strong>。</li></ul><h2 id="8-setAccessible"><a href="#8-setAccessible" class="headerlink" title="8.setAccessible"></a>8.setAccessible</h2><p>➢Method和Field、Construictor对象都有setAccessible()方法。</p><p>➢setAccessible作用是启动和禁用访问安全检查的开关。</p><p>➢参数值为true则指示反射的对象在使用时应该取消Java语言访问检查。</p><p>➢提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true。➢使得原本无法访问的私有成员也可以访问</p><p>➢参数值为false则指示反射的对象应该实施Java语言访问检查</p><h2 id="9-反射操作泛型"><a href="#9-反射操作泛型" class="headerlink" title="9.反射操作泛型"></a>9.反射操作泛型</h2><p>➢Java采用泛型擦除的机制来引入泛型, Java中的泛型仅仅是给编译器javac使用的,确保数据的</p><p>安全性和免去强制类型转换问题,但是,一旦编译完成,所有和泛型有关的类型全部擦除</p><p>➢为了通过反射操作这些类型, Java新增了ParameterizedType , GenericArrayType,</p><p>TypeVariable和WildcardType几种类型来代表不能被归一到Class类中的类型但是又和原始类</p><p>型齐名的类型.</p><p>➢ParameterizedType :表示一种参数化类型,比如Collection<String></String></p><p>➢GenericArrayType :表示一种元素类型是参数化类型或者类型变量的数组类型     </p><p>➢TypeVariable :是各种类型变量的公共父接口</p><p>➢WildcardType :代表- -种通配符类型表达式</p><h2 id="10-使用反射机制读取注解信息"><a href="#10-使用反射机制读取注解信息" class="headerlink" title="10.使用反射机制读取注解信息"></a>10.使用反射机制读取注解信息</h2><table><thead><tr><th>类型</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Annotation</td><td>getAnnotation(Class annotationType)</td><td>若存在该元素的指定类型的注解，则返回这些注解，否则，返回 null</td></tr><tr><td>Annotation[]</td><td>getAnnotations()</td><td>返回此元素上存在的所有注解</td></tr><tr><td>Annotation[]</td><td>getDeclaredAnnotations()</td><td>返回该元素上已声明的所有注解，否则返回 null，使用该方法可以自由修改返回的数组</td></tr><tr><td>boolean</td><td>isAnnotationPresent(Class annotationType)</td><td>若指定类型的注解存在于此元素上，则返回 true，否则返回 false</td></tr></tbody></table><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<span class="hljs-keyword">import</span> java.lang.annotation.Retention;<span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<span class="hljs-keyword">import</span> java.lang.annotation.Target;<span class="hljs-keyword">import</span> java.lang.reflect.Field;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test01</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//通过反射获取Class对象</span>        Class sudent = Class.forName(<span class="hljs-string">"Sudent"</span>);        <span class="hljs-comment">//获取当前对象的所有属性</span>        Field name= sudent.getDeclaredField(<span class="hljs-string">"name"</span>);        <span class="hljs-comment">//获取某个注解</span>        myAnnotation annotation = name.getAnnotation(myAnnotation<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        <span class="hljs-comment">//获取注解的信息</span>        System.out.println(annotation);        System.out.println(annotation.fid());        System.out.println(annotation.length());        System.out.println(annotation.type());    &#125;&#125;<span class="hljs-comment">//实体类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sudent</span></span>&#123;    <span class="hljs-meta">@myAnnotation</span>(fid = <span class="hljs-string">"吕"</span>,type = <span class="hljs-string">"String"</span>,length =<span class="hljs-number">5</span>)    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Sudent</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, <span class="hljs-keyword">int</span> id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.age = age;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Sudent</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.age = age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;&#125;<span class="hljs-comment">//自定义注解</span><span class="hljs-meta">@Target</span>(ElementType.FIELD)<span class="hljs-comment">//作用与属性上</span><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-comment">//作用时机</span><span class="hljs-meta">@interface</span> myAnnotation&#123;    <span class="hljs-function">String  <span class="hljs-title">fid</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">String  <span class="hljs-title">type</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//运行结果</span><span class="hljs-meta">@myAnnotation</span>(fid=<span class="hljs-string">"吕"</span>, type=<span class="hljs-string">"String"</span>, length=<span class="hljs-number">5</span>)吕<span class="hljs-number">5</span>String</code></pre><h1 id="三-类的加载与ClassLoader的理解"><a href="#三-类的加载与ClassLoader的理解" class="headerlink" title="三.类的加载与ClassLoader的理解"></a>三.类的加载与ClassLoader的理解</h1><h2 id="1-加载原理-加载，链接，初始化"><a href="#1-加载原理-加载，链接，初始化" class="headerlink" title="1.加载原理(加载，链接，初始化)"></a>1.加载原理(加载，链接，初始化)</h2><p><strong>➢加载:将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数   据结构,然后生成一个代表这个类的java.lang.Class对象.</strong></p><ul><li><p>通过类型的完全限定名，产生一个代表该类型的二进制数据流</p></li><li><p>解析这个二进制数据流为方法区内的内部数据结构</p></li><li><p>创建一个表示该类型的java.lang.Class类的实例</p></li></ul><p><strong>另外如果一个类装载器在预先装载的时遇到缺失或错误的class文件，它需要等到程序首次主动使用该类时才报告错误。</strong></p><p><strong>➢链接:将Java类的二进制代码合并到JVM的运行状态之中的过程。</strong></p><ul><li>验证:确保加载的类信息符合JVM规范，没有安全方面的问题</li><li>准备:正式为类变量(static) 分配内存并设置类变量默认初始值的阶段,这些内存都将在方法区中进行分配。</li><li>解析: 虚拟机常量池内的符号引用(常量名)替换为直接引用(地址)的过程。</li></ul><p><strong>➢初始化:</strong></p><ul><li>当创建某个类的新实例时（如通过new或者反射，克隆，反序列化等）</li><li>当调用某个类的静态方法时</li><li>当使用某个类或接口的静态字段时</li><li>当调用Java API中的某些反射方法时，比如类Class中的方法，或者java.lang.reflect中的类的方法时</li><li>当初始化某个子类时</li><li>当虚拟机启动某个被标明为启动类的类（即包含main方法的那个类）</li></ul><p><strong>Java编译器会收集所有的类变量初始化语句和类型的静态初始化器，将这些放到一个特殊的方法中：clinit()</strong>。</p><p><strong>static块的执行发生在“初始化”的阶段。初始化阶段，jvm主要完成对静态变量的初始化，静态块执行等工作。</strong></p><ul><li>静态代码块的执行时机(<a href="https://blog.csdn.net/BranStark/article/details/49051569" target="_blank" rel="noopener">https://blog.csdn.net/BranStark/article/details/49051569</a>)</li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lv;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test02</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        A a=<span class="hljs-keyword">new</span> A();        System.out.println(a.m);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;    <span class="hljs-keyword">static</span>&#123;        System.out.println(<span class="hljs-string">"A类静态代码初始化"</span>);        m=<span class="hljs-number">300</span>;    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> m=<span class="hljs-number">100</span>;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">A</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"A的无参"</span>);    &#125;&#125;<span class="hljs-comment">//运行结果</span>A类静态代码初始化A的无参<span class="hljs-number">100</span></code></pre><p><img src="https://i.loli.net/2020/05/29/vRBCwWqDeNum4p3.png" srcset="/img/loading.gif" alt="QQ图片20200529122222.png"></p><h2 id="2-类加载器"><a href="#2-类加载器" class="headerlink" title="2.类加载器"></a>2.类加载器</h2><p>➢类加载的作用:将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang(Class对象)作为方法区中类数据的访问入口。</p><p>➢<strong>类缓存</strong>:标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载(缓存)一段时间。不过JVM垃圾回收机制可以回收这些Class对象</p><h2 id="3-类加载器的类型"><a href="#3-类加载器的类型" class="headerlink" title="3.类加载器的类型"></a>3.类加载器的类型</h2><p>在jvm中有三个内置类加载器，Bootstrap ClassLoader，Extension ClassLoader，Application ClassLoader。</p><p>Bootstrap ClassLoader：启动(根)类加载器，用于加载java核心库jre/lib/rt.jar。</p><p>Extension ClassLoader：扩展类加载器，用于加载java扩展库jre/ext/*.jar。</p><p>Application ClassLoader：应用程序(系统)类加载器，自己写的代码都是使用这个加载器来加载的。</p><p><img src="https://i.loli.net/2020/05/29/PrMZFofyUgLt7Wn.png" srcset="/img/loading.gif" alt="image-20200529100305226.png"></p><p><strong>双亲委派机制：自己定义一个类，通过自下往上的检查看看父类加载器是否已经定义了这个类，如果定义了，那么自己写的这个类就无效。</strong></p><p>例如：自己定义一个Java.lang.String类，发现父类加载器中已经定义了，我们自己的这个String类就无效了。</p><h1 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h1><p><img src="https://i.loli.net/2020/05/29/kUV1CqjQrHxXdY4.png" srcset="/img/loading.gif" alt="image-20200510090030648.png"></p><p>这里要注意一个重点，获取Class对象信息的时候是<strong>运行时</strong>，只有在<strong>运行时</strong>才能通过Class获取类的信息。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>注解和反射</title>
    <link href="/2020/05/29/JavaSE/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/"/>
    <url>/2020/05/29/JavaSE/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="一-注解"><a href="#一-注解" class="headerlink" title="一.注解"></a>一.注解</h1><h2 id="1-什么是注解"><a href="#1-什么是注解" class="headerlink" title="1.什么是注解"></a>1.什么是注解</h2><p>◆Annotation是从JDK5.0开始引入的新技术.</p><p>◆Annotation的作用 :</p><p>➢不是程序本身,可以对程序作出解释.(这一-点和注释(comment)没什么区别)</p><p>➢<strong>可以被其他程序(比如:编译器等)读取.</strong></p><p>◆Annotation的格式 :</p><p>➢注解是以<strong>“@注释名”</strong>在代码中存在的,还可以添加一-些参数值,例</p><p>如:@SuppressWarnings(value=”unchecked”). .</p><p>◆Annotation在哪里使用?</p><p>➢可以附加在<strong>package , class , method , field **等上面,相当于给他们添加了额外的辅助信息，我们可以通过</strong>反射机制编程实现**对这些元数据的访问</p><h2 id="2-内置注解"><a href="#2-内置注解" class="headerlink" title="2.内置注解"></a>2.内置注解</h2><p>➢@Override :定义在java.lang.Override中,此注释<strong>只适用于修辞方法</strong>,表示-<strong>一个方法声明打算重写超类中的另一个方法声明</strong>.</p><p>➢@Deprecated :定义在java.lang.Deprecated中,此注释<strong>可以用于修辞方法,属性,类,表示不鼓励程序员使用这样的元素, 通常是因为它很危险或者存在更好的选择.</strong></p><p>➢@SuppressWarnings :定义在java.lang.SuppressWarnings中用来<strong>抑制编译时的警告信息.</strong></p><p>​      与前两个注释有所不同你需要添加一个<strong>参数</strong>才能正确使用，这些参数都是已经定义好了的，我们选择性的使用就好了.</p><ul><li><p>@SuppressWarnings(“all”)</p></li><li><p>@SuppressWarnings(“unchecked”)</p></li><li><p>@SuppressWarnings(value={“unchecked”,”deprecation”})</p></li><li><p>等等….</p></li></ul><h2 id="3-元注解"><a href="#3-元注解" class="headerlink" title="3.元注解"></a>3.元注解</h2><p>◆元注解的作用就是负责注解其他注解, Java定义了4个标准的meta-annotation类型,他们被用来提供对其他annotation类型作说明.</p><p> ◆这些类型和它们所支持的类在java.lang.annotation包中可以找到.</p><p> <strong>( @Target , @Retention，@Documented , @Inherited )</strong><br>          ➢@Target:<strong>用于描述注解的使用范围(即:被描述的注解可以用在什么地方)</strong></p><p>  ➢@Retention :<strong>表示需要在什么级别保存该注释信息,用于描述注解的生命周期</strong></p><p>  ➢<strong>(SOURCE &lt; CLASS &lt; RUNTIME)</strong></p><p>  ➢<strong>@Document</strong>:说明该注解将被包含在javadoc中</p><p>  ➢<strong>@Inherited</strong>: 说明子类可以继承父类中的该注解</p><p>  ➢<strong>@Native</strong>:指定字段是一个常量，其值引用native code。</p><p>  ➢<strong>@Repeatable</strong>注解上可以使用重复注解，即可以在一个地方可以重复使用同一个注解，像spring中的包扫描注解就使用了这个。</p><h2 id="4-自定义注解"><a href="#4-自定义注解" class="headerlink" title="4.自定义注解"></a>4.自定义注解</h2><p>➢使用@interface自定义注解时,自动<strong>继承</strong>了<strong>java.lang. annotation.Annotation</strong>接口</p><p>➢分析:</p><ul><li><p><strong>@ interface</strong>用来声明一个注解,<strong>格式: public @ interface注解名{定义内容}</strong></p></li><li><p>其中的每一一个方法实际 上是声明了一一个配置参数.</p></li><li><p>方法的名称就是参数的名称. ；例如  <strong>int age() ,age就是它的参数名称</strong>  </p></li><li><p>返回值类型就是参数的类型(<strong>返回值只能是基本类型,Class , String , enum</strong> ).</p></li><li><p>可以通过<strong>default</strong>来声明参数的默认值。</p></li><li><p>如果只有一-<strong>个参数成员,一般参数名为value</strong>。</p></li><li><p>注解元素必须要有值, 我们定义注解元素时,经常使用空字符串，0作为默认值。</p></li><li><p>如果没有默认值，我们必须自己手动赋值。</p></li><li><p>如果定义到类中不用写public也可以。</p><pre><code class="hljs Java"><span class="hljs-comment">//自定义注解</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test03</span> </span>&#123;<span class="hljs-comment">//注解可以显示赋值，如果没有默认值， 我们就必须给注解赋值</span><span class="hljs-meta">@MyAnnotation</span>2(age = <span class="hljs-number">18</span>,name = <span class="hljs-string">"吕"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;&#125;    <span class="hljs-meta">@MyAnnotation</span>3(<span class="hljs-string">"吕"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-meta">@Target</span>(&#123;ElementType.TYPE,ElementType.METHOD&#125;)<span class="hljs-meta">@Retention</span>(RetentionPolicy . RUNTIME)<span class="hljs-meta">@interface</span> MyAnnotation2&#123;<span class="hljs-comment">//注解的参数:参数类型+参数名();</span><span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">age</span><span class="hljs-params">()</span> </span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> -1</span>;<span class="hljs-comment">//如果默认值为-1,代表不存在。</span>String[] schools() <span class="hljs-keyword">default</span> &#123;<span class="hljs-string">"吕"</span>, <span class="hljs-string">"清华大学"</span>&#125;;&#125;    <span class="hljs-meta">@Target</span>(&#123;ElementType. TYPE , ElementType .METHOD&#125;)<span class="hljs-meta">@Retention</span>( RetentionPolicy . RUNTIME)<span class="hljs-meta">@interface</span> MyAnnotation3&#123;<span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> </span>;<span class="hljs-comment">//如果只有一个值，用value表示</span>&#125;</code></pre></li></ul><h1 id="二-静态语言和动态语言"><a href="#二-静态语言和动态语言" class="headerlink" title="二 .静态语言和动态语言"></a>二 .静态语言和动态语言</h1><h2 id="1-动态语言"><a href="#1-动态语言" class="headerlink" title="1.动态语言"></a>1.动态语言</h2><p>➢是一类在运行时可以改变其结构的语言:例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。</p><p>➢主要动态语言: Object-C、 C#、 JavaScript、 PHP、Python等。</p><h2 id="2-静态语言"><a href="#2-静态语言" class="headerlink" title="2.静态语言"></a>2.静态语言</h2><p>➢与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、 C、C++.</p><p>➢Java不是动态语言，但Java可以称之为“准动态语言”。即Java有一 定的动态性,我们可以利用反射机制获得类似动态语言的特性。Java的动态性让编程的时候更加灵活!</p><h1 id="三-反射机制"><a href="#三-反射机制" class="headerlink" title="三. 反射机制"></a>三. 反射机制</h1><h2 id="1-Java-Reflection"><a href="#1-Java-Reflection" class="headerlink" title="1.Java Reflection"></a>1.Java Reflection</h2><p>➢Reflection (反射)是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</p><p>Class C = Class.forName(jiva.lang.String”)</p><p>➢加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象(<strong>一 个类只有一个Class对象</strong>)，这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个<strong>对象就像一面镜子， 透过这个镜子看到类的结构，所以,我们形象的称之为:反射。</strong></p><blockquote><p>正常方式:引入需 要的”包类”名称一&gt; 通过new实例化取 得实例化对象</p></blockquote><blockquote><p>反射方式:实例化对象一getClass()方法一&gt; 得到完整的“包类”名称</p></blockquote><h2 id="2-Java反射机制研究及应用"><a href="#2-Java反射机制研究及应用" class="headerlink" title="2.Java反射机制研究及应用"></a>2.Java反射机制研究及应用</h2><p>Java反射机制提供的功能</p><p>➢在运行时判断任意-个对象所属的类</p><p>➢在运行时构造任意一个类的对象</p><p>➢在运行时判断任意一个类所具有的成员变量和方法➢在运行时获取泛型信息</p><p>➢在运行时调用任意一个对象的成员变量和方法➢在运行时处理注解</p><p>➢生成动态代理</p><p>➢…</p><h2 id="3-Java反射优点和缺点"><a href="#3-Java反射优点和缺点" class="headerlink" title="3.Java反射优点和缺点"></a>3.Java反射优点和缺点</h2><p>优点:</p><blockquote><p>可以实现动态创建对象和编译，体现出很大的灵活性</p></blockquote><p>缺点:</p><blockquote><p>对性能有影响。使用反射基本上是一-种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于直接执行相同的操作。</p></blockquote><h2 id="4-概念"><a href="#4-概念" class="headerlink" title="4.概念"></a>4.概念</h2><p><img src="https://i.loli.net/2020/05/29/mrN6TbQIjh14BAe.png" srcset="/img/loading.gif" alt="image-20200508173019802.png"></p><ul><li><p>源代码阶段：在硬盘中以.class的方式存储 </p></li><li><p>Class类对象阶段和运行阶段：在内存中存储 </p></li></ul><h2 id="5-Class类"><a href="#5-Class类" class="headerlink" title="5.Class类"></a>5.Class类</h2><p>编写完java文件后，jvm是不能直接运行java文件的，首先要将java文件编译成class文件以后，jvm再把class文件<strong>加载</strong>到内存中，<strong>创建一个Class对象</strong>，这时候才可以使用这个类。加载这个动作，就是由<strong>类加载器</strong>完成的。jRE都为其保留一个不变的Class类型的对象。一个Class对象包含了特定某个结构<strong>(class/interface/enum/annotation/primitive type/void/[])</strong>的有关信息。</p><p>➢Class本身也是一-个类</p><p>➢Class 对象只能由系统建立对象</p><p>➢一个加载的类在JVM中只会有一个Class实例</p><p>➢一个Class对象对应的是一 个加载到JVM中的一个.class文件</p><p>➢每个类的实例都会记得自己是由哪个Class实例所生成</p><p>➢通过Class可以完整地得到一个类中的所有被加载的结构</p><p>➢Class类 是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象</p><p>➢基本的 Java 类型（boolean、byte、char、short、int、long、float 和 double）和关键字 void 也都对应一个 Class 对象。<br>        ➢每个<strong>数组</strong>属于被映射为 Class 对象的一个类，所有具有<strong>相同元素类型和维数的数组</strong>都共享该 Class 对象。</p><p><strong>Class类就是用来描述类的信息的。Class也是一种类型，它专门用来描述类的特征。</strong></p><p><img src="https://i.loli.net/2020/05/29/Eha2dLHwVlnfMUS.png" srcset="/img/loading.gif" alt="image-20200510085958436.png"></p><h2 id="6-获取Class对象的功能"><a href="#6-获取Class对象的功能" class="headerlink" title="6.获取Class对象的功能"></a>6.获取Class对象的功能</h2><p><img src="https://i.loli.net/2020/05/29/TRr3WMPf7k4AhbU.png" srcset="/img/loading.gif" alt="image-20200508174941636.png"></p><table><thead><tr><th align="left">方法名</th><th>功能说明</th></tr></thead><tbody><tr><td align="left">static GlassforName(String name)</td><td>返回指定类名rame的Class对象</td></tr><tr><td align="left">Object newlnstance()</td><td>调用缺省构造函数，返回Class对象的一一个实例</td></tr><tr><td align="left">getName()</td><td>返回此Class对象所表示的实体(类，接口，数组类或void)的名称。</td></tr><tr><td align="left">Class getSuperClass()</td><td>返回当前Class对象的父类的Class对象</td></tr><tr><td align="left">Class[] getInterfaces()</td><td>获取当前Class对象的所有接口</td></tr><tr><td align="left">Class Loader getClassLoader()</td><td>返回该类的类加载器</td></tr><tr><td align="left">Constructor[] getConstructors()</td><td>返回一个包含某些Constructor对象的数组，获取有参构造</td></tr><tr><td align="left">Method getMothed(String name,Class.. T)</td><td>返回一-个Method对象，此对象的形参类型为paramType</td></tr><tr><td align="left">Field[] getDeclaredFields()</td><td>返回Field对象属性的一个数组</td></tr><tr><td align="left">setAccessible</td><td>true:打开权限。</td></tr></tbody></table><h2 id="7-getDeclaredxxx和getxxx的区别"><a href="#7-getDeclaredxxx和getxxx的区别" class="headerlink" title="7.getDeclaredxxx和getxxx的区别"></a>7.getDeclaredxxx和getxxx的区别</h2><blockquote><p>getxxx：此方法获取的是所有public方法级别的xxx。</p></blockquote><blockquote><p>getDeclaredxxx：此方法获得的是自身类的所有xxx。包括公有(public)、私有(private)xxx等，而且不受限于访问权限，但是限定本类(可以访问本身类的xxx或者内部类的xxx)。</p></blockquote><p>例子：</p><ul><li>getMethod():此方法获取的是所有<strong>public方法级别的方法，包括从父类继承的方法</strong>。 </li><li>getDeclaredMethod():此方法获得的是自身类的所有方法，包括<strong>公有(public)、私有(private)方法等，而且不受限于访问权限，但是限定本类(可以访问本身类的方法或者内部类的方法)</strong>。</li></ul><h2 id="8-setAccessible"><a href="#8-setAccessible" class="headerlink" title="8.setAccessible"></a>8.setAccessible</h2><p>➢Method和Field、Construictor对象都有setAccessible()方法。</p><p>➢setAccessible作用是启动和禁用访问安全检查的开关。</p><p>➢参数值为true则指示反射的对象在使用时应该取消Java语言访问检查。</p><p>➢提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true。➢使得原本无法访问的私有成员也可以访问</p><p>➢参数值为false则指示反射的对象应该实施Java语言访问检查</p><h2 id="9-反射操作泛型"><a href="#9-反射操作泛型" class="headerlink" title="9.反射操作泛型"></a>9.反射操作泛型</h2><p>➢Java采用泛型擦除的机制来引入泛型, Java中的泛型仅仅是给编译器javac使用的,确保数据的</p><p>安全性和免去强制类型转换问题,但是,一旦编译完成,所有和泛型有关的类型全部擦除</p><p>➢为了通过反射操作这些类型, Java新增了ParameterizedType , GenericArrayType,</p><p>TypeVariable和WildcardType几种类型来代表不能被归一到Class类中的类型但是又和原始类</p><p>型齐名的类型.</p><p>➢ParameterizedType :表示一种参数化类型,比如Collection<String></String></p><p>➢GenericArrayType :表示一种元素类型是参数化类型或者类型变量的数组类型     </p><p>➢TypeVariable :是各种类型变量的公共父接口</p><p>➢WildcardType :代表- -种通配符类型表达式</p><h2 id="10-使用反射机制读取注解信息"><a href="#10-使用反射机制读取注解信息" class="headerlink" title="10.使用反射机制读取注解信息"></a>10.使用反射机制读取注解信息</h2><table><thead><tr><th>类型</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Annotation</td><td>getAnnotation(Class annotationType)</td><td>若存在该元素的指定类型的注解，则返回这些注解，否则，返回 null</td></tr><tr><td>Annotation[]</td><td>getAnnotations()</td><td>返回此元素上存在的所有注解</td></tr><tr><td>Annotation[]</td><td>getDeclaredAnnotations()</td><td>返回该元素上已声明的所有注解，否则返回 null，使用该方法可以自由修改返回的数组</td></tr><tr><td>boolean</td><td>isAnnotationPresent(Class annotationType)</td><td>若指定类型的注解存在于此元素上，则返回 true，否则返回 false</td></tr></tbody></table><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<span class="hljs-keyword">import</span> java.lang.annotation.Retention;<span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<span class="hljs-keyword">import</span> java.lang.annotation.Target;<span class="hljs-keyword">import</span> java.lang.reflect.Field;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test01</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//通过反射获取Class对象</span>        Class sudent = Class.forName(<span class="hljs-string">"Sudent"</span>);        <span class="hljs-comment">//获取当前对象的所有属性</span>        Field name= sudent.getDeclaredField(<span class="hljs-string">"name"</span>);        <span class="hljs-comment">//获取某个注解</span>        myAnnotation annotation = name.getAnnotation(myAnnotation<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        <span class="hljs-comment">//获取注解的信息</span>        System.out.println(annotation);        System.out.println(annotation.fid());        System.out.println(annotation.length());        System.out.println(annotation.type());    &#125;&#125;<span class="hljs-comment">//实体类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sudent</span></span>&#123;    <span class="hljs-meta">@myAnnotation</span>(fid = <span class="hljs-string">"吕"</span>,type = <span class="hljs-string">"String"</span>,length =<span class="hljs-number">5</span>)    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Sudent</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, <span class="hljs-keyword">int</span> id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.age = age;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Sudent</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.age = age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;&#125;<span class="hljs-comment">//自定义注解</span><span class="hljs-meta">@Target</span>(ElementType.FIELD)<span class="hljs-comment">//作用与属性上</span><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-comment">//作用时机</span><span class="hljs-meta">@interface</span> myAnnotation&#123;    <span class="hljs-function">String  <span class="hljs-title">fid</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">String  <span class="hljs-title">type</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//运行结果</span><span class="hljs-meta">@myAnnotation</span>(fid=<span class="hljs-string">"吕"</span>, type=<span class="hljs-string">"String"</span>, length=<span class="hljs-number">5</span>)吕<span class="hljs-number">5</span>String</code></pre><h1 id="三-类的加载与ClassLoader的理解"><a href="#三-类的加载与ClassLoader的理解" class="headerlink" title="三.类的加载与ClassLoader的理解"></a>三.类的加载与ClassLoader的理解</h1><h2 id="1-加载原理-加载，链接，初始化"><a href="#1-加载原理-加载，链接，初始化" class="headerlink" title="1.加载原理(加载，链接，初始化)"></a>1.加载原理(加载，链接，初始化)</h2><p><strong>➢加载:将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数   据结构,然后生成一个代表这个类的java.lang.Class对象.</strong></p><ul><li><p>通过类型的完全限定名，产生一个代表该类型的二进制数据流</p></li><li><p>解析这个二进制数据流为方法区内的内部数据结构</p></li><li><p>创建一个表示该类型的java.lang.Class类的实例</p></li></ul><p><strong>另外如果一个类装载器在预先装载的时遇到缺失或错误的class文件，它需要等到程序首次主动使用该类时才报告错误。</strong></p><p><strong>➢链接:将Java类的二进制代码合并到JVM的运行状态之中的过程。</strong></p><ul><li>验证:确保加载的类信息符合JVM规范，没有安全方面的问题</li><li>准备:正式为类变量(static) 分配内存并设置类变量默认初始值的阶段,这些内存都将在方法区中进行分配。</li><li>解析: 虚拟机常量池内的符号引用(常量名)替换为直接引用(地址)的过程。</li></ul><p><strong>➢初始化:</strong></p><ul><li>当创建某个类的新实例时（如通过new或者反射，克隆，反序列化等）</li><li>当调用某个类的静态方法时</li><li>当使用某个类或接口的静态字段时</li><li>当调用Java API中的某些反射方法时，比如类Class中的方法，或者java.lang.reflect中的类的方法时</li><li>当初始化某个子类时</li><li>当虚拟机启动某个被标明为启动类的类（即包含main方法的那个类）</li></ul><p><strong>Java编译器会收集所有的类变量初始化语句和类型的静态初始化器，将这些放到一个特殊的方法中：clinit()</strong>。</p><p><strong>static块的执行发生在“初始化”的阶段。初始化阶段，jvm主要完成对静态变量的初始化，静态块执行等工作。</strong></p><ul><li>静态代码块的执行时机(<a href="https://blog.csdn.net/BranStark/article/details/49051569" target="_blank" rel="noopener">https://blog.csdn.net/BranStark/article/details/49051569</a>)</li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lv;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test02</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        A a=<span class="hljs-keyword">new</span> A();        System.out.println(a.m);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;    <span class="hljs-keyword">static</span>&#123;        System.out.println(<span class="hljs-string">"A类静态代码初始化"</span>);        m=<span class="hljs-number">300</span>;    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> m=<span class="hljs-number">100</span>;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">A</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"A的无参"</span>);    &#125;&#125;<span class="hljs-comment">//运行结果</span>A类静态代码初始化A的无参<span class="hljs-number">100</span></code></pre><p><img src="https://i.loli.net/2020/05/29/vRBCwWqDeNum4p3.png" srcset="/img/loading.gif" alt="QQ图片20200529122222.png"></p><h2 id="2-类加载器"><a href="#2-类加载器" class="headerlink" title="2.类加载器"></a>2.类加载器</h2><p>➢类加载的作用:将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang(Class对象)作为方法区中类数据的访问入口。</p><p>➢<strong>类缓存</strong>:标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载(缓存)一段时间。不过JVM垃圾回收机制可以回收这些Class对象</p><h2 id="3-类加载器的类型"><a href="#3-类加载器的类型" class="headerlink" title="3.类加载器的类型"></a>3.类加载器的类型</h2><p>在jvm中有三个内置类加载器，Bootstrap ClassLoader，Extension ClassLoader，Application ClassLoader。</p><p>Bootstrap ClassLoader：启动(根)类加载器，用于加载java核心库jre/lib/rt.jar。</p><p>Extension ClassLoader：扩展类加载器，用于加载java扩展库jre/ext/*.jar。</p><p>Application ClassLoader：应用程序(系统)类加载器，自己写的代码都是使用这个加载器来加载的。</p><p><img src="https://i.loli.net/2020/05/29/PrMZFofyUgLt7Wn.png" srcset="/img/loading.gif" alt="image-20200529100305226.png"></p><p><strong>双亲委派机制：自己定义一个类，通过自下往上的检查看看父类加载器是否已经定义了这个类，如果定义了，那么自己写的这个类就无效。</strong></p><p>例如：自己定义一个Java.lang.String类，发现父类加载器中已经定义了，我们自己的这个String类就无效了。</p><h1 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h1><p><img src="https://i.loli.net/2020/05/29/kUV1CqjQrHxXdY4.png" srcset="/img/loading.gif" alt="image-20200510090030648.png"></p><p>这里要注意一个重点，获取Class对象信息的时候是<strong>运行时</strong>，只有在<strong>运行时</strong>才能通过Class获取类的信息。</p>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mvaen</title>
    <link href="/2020/05/26/Java/Maven/"/>
    <url>/2020/05/26/Java/Maven/</url>
    
    <content type="html"><![CDATA[<h1 id="Mvaen"><a href="#Mvaen" class="headerlink" title="Mvaen"></a>Mvaen</h1><h2 id="maven是什么【what】"><a href="#maven是什么【what】" class="headerlink" title="maven是什么【what】"></a>maven是什么【what】</h2><p><strong>① maven是一款服务于java平台的自动化构建工具</strong></p><p>make-&gt;Ant-&gt;Maven-&gt;Gradle</p><p>名字叫法：我们可以叫妹文也可以叫麦文，但是没有叫妈文的。</p><p><strong>② 构建</strong></p><p><strong>构建定义：把动态的Web工程经过编译得到的编译结果部署到服务器上的整个过程。</strong></p><p>编译：java源文件[.java]-&gt;编译-&gt;Class字节码文件[.class]</p><p>部署：最终在sevlet容器中部署的不是动态web工程，而是编译后的文件</p><p><strong>③ 构建的各个环节</strong></p><ul><li>清理clean：将以前编译得到的旧文件class字节码文件删除</li><li>编译compile：将java源程序编译成class字节码文件</li><li>测试test：自动测试，自动调用junit程序</li><li>报告report：测试程序执行的结果</li><li>打包package：动态Web工程打War包，java工程打jar包</li><li>安装install：Maven特定的概念—–将打包得到的文件复制到“仓库”中的指定位置</li><li>部署deploy：将动态Web工程生成的war包复制到Servlet容器下，使其可以运行</li></ul><h2 id="我为什么要学习这个技术"><a href="#我为什么要学习这个技术" class="headerlink" title="我为什么要学习这个技术?"></a>我为什么要学习这个技术?</h2><p><strong>① 一个项目就是一个工程</strong></p><p>如果项目非常庞大，就不适合使用package来划分模块，最好是每一个模块对应一个工程，利于分工协作。借助于maven就可以将一个项目拆分成多个工程</p><p><strong>② 项目中使用jar包，需要“复制”、“粘贴”项目的lib中</strong></p><p>同样的jar包重复的出现在不同的项目工程中，你需要做不停的复制粘贴的重复工作。借助于maven，可以将jar包保存在“仓库”中，不管在哪个项目只要使用引用即可就行。</p><p><strong>③ jar包需要的时候每次都要自己准备好或到官网下载</strong></p><p>借助于maven我们可以使用统一的规范方式下载jar包，规范</p><p><strong>④ jar包版本不一致的风险</strong></p><p>不同的项目在使用jar包的时候，有可能会导致各个项目的jar包版本不一致，导致未执行错误。借助于maven，所有的jar包都放在“仓库”中，所有的项目都使用仓库的一份jar包。</p><p><strong>⑤ 一个jar包依赖其他的jar包需要自己手动的加入到项目中</strong></p><p>FileUpload组件-&gt;IO组件，commons-fileupload-1.3.jar依赖于commons-io-2.0.1.jar</p><p>极大的浪费了我们导入包的时间成本，也极大的增加了学习成本。借助于maven，它会自动的将依赖的jar包导入进来。</p><h2 id="1Maven项目架构管理工具"><a href="#1Maven项目架构管理工具" class="headerlink" title="1Maven项目架构管理工具"></a>1Maven项目架构管理工具</h2><p>我们目前用来就是方便导入jar包的! .</p><p>Maven的核心思想:<strong>约定大于配置</strong></p><p>●有约束，不要去违反</p><h2 id="2-下载Maven"><a href="#2-下载Maven" class="headerlink" title="2.下载Maven"></a>2.下载Maven</h2><p><img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/ZOHqlMnlPhi5393oWyanhHqrZG7FpXGxC7sQr6R97OtH0bRhvMOD*xEV2nRbEpN5MAvzPD25oOqcpjVy1j2xxw!!/b&bo=CgXoAgAAAAADB8c!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503094338353"></p><h2 id="3-配置MAVEN的环境变量"><a href="#3-配置MAVEN的环境变量" class="headerlink" title="3.配置MAVEN的环境变量"></a>3.配置MAVEN的环境变量</h2><p>   在我们的系统环境变量中</p><ul><li><p>配置如下配置</p><pre><code class="hljs dos">创建M2_HOME      maven目录下的bin目录      创建MAVEN_HOME    maven的目录        在系统的<span class="hljs-built_in">path</span>中配置   <span class="hljs-variable">%MAVEN_HOMEN%</span>\bin</code></pre><ul><li>然后命令行查看maven版本  </li></ul><pre><code class="hljs applescript">mvn -<span class="hljs-built_in">version</span></code></pre></li><li><p>测试Maven是否安装成功</p></li></ul><h2 id="4-阿里云镜像"><a href="#4-阿里云镜像" class="headerlink" title="4.阿里云镜像"></a>4.阿里云镜像</h2><ul><li>镜像： mirrors</li></ul><p>​        作用：加速我们的下载</p><ul><li><p>国内建议使用阿里云的镜像</p></li><li><p>在Maven目录下的 conf/settings.xml中的<mirrors>标签添加如下代码</mirrors></p></li></ul><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span>    <span class="hljs-comment">&lt;!--This sends everything else to /public --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>*<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Nexus aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span></code></pre><h2 id="5-本地仓库"><a href="#5-本地仓库" class="headerlink" title="5.本地仓库"></a>5.本地仓库</h2><p>在本地仓库，远程仓库：</p><p><strong>建立一个本地仓库</strong>：Maven目录下的conf/ settings.xml中的<localRepository>标签添加如下代码</localRepository></p><ul><li>你要创建本地仓库的位置</li></ul><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>D:\Maven\apache-maven-3.6.3-bin\apache-maven-3.6.3\maven-repo<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span></code></pre><h2 id="6-在idea中使用maven"><a href="#6-在idea中使用maven" class="headerlink" title="6.在idea中使用maven"></a>6.在idea中使用maven</h2><h3 id="1-模板"><a href="#1-模板" class="headerlink" title="1.模板"></a>1.模板</h3><p>   1.启动IDEA</p><p>   2.创建一个MAVEN的项目</p><p>   3.<img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/tS3tY63exiZNUWwJevnZGpjkOvkl6TXRQ40rVIQWqndHCGFlJM24.b8cp5Bhi0760sIT*vmYHlDAAE*4G3xMQYUaCfxy*6eWiynvbLK1THM!/b&bo=IwQWAwAAAAADNyA!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503100325085"></p><p>4.<img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/ZOHqlMnlPhi5393oWyanhN5woCzJWlLEwBlIhpMvDiWxoSv*oIxLAN*c1CTxo5dygx5ufDvgAReTPb3d0bxb0A!!/b&bo=zQO*AAAAAAADB1M!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503100621755"></p><p>5.<img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/tS3tY63exiZNUWwJevnZGlx1fja9x7BSAPvEhKDeA5NzV3A6V*3OhIp19fuMltbbS0lAUBgc66G.IeeLNAmrQlTcZibAY0Peg.X3Qt67254!/b&bo=*AMVAgAAAAADJ.o!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503100746624"></p><p>6.<img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/tS3tY63exiZNUWwJevnZGvohyrN6y5xFw4w6B1nNIQV3bFEP3UeUB8dIDzurXv52iJ0uvEWqtZ8kd6QteFFK0H2UWQklOypXuLnx741A9EA!/b&bo=aQekAwAAAAADN9s!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503102709240"></p><p>7.<img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/tS3tY63exiZNUWwJevnZGsNGOnR4ZwHd1Tp6V0Cax7UVu9FuzPk7LAZ04gCKo1gR4Ga9fTCANaeJndprfqRlH5qJ4.j3Z0RywnALXGnPls8!/b&bo=AwTKAgAAAAADN90!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503111805878">  </p><p>8.</p><p><img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/tS3tY63exiZNUWwJevnZGqluifhDrveJkyhhr48ynLc7AzSf*WYDcIujlhCiNS6yVniyxka0*ycIparUgp8LOMdROw37TsnmMB.vk24Z698!/b&bo=EwTQAgAAAAADN9c!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503111945369"></p><h3 id="2-正常创建"><a href="#2-正常创建" class="headerlink" title="2.正常创建"></a>2.正常创建</h3><p><strong>不勾选内容，直接下一步</strong></p><p><img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/tS3tY63exiZNUWwJevnZGuXH3gyxcxGGTvx6TJjK6qSvtWod5KayNvS.iTPSrtHqWVZYdC2KY..WDuGD9ygaAZfhpIW00VlXYKugSOLyG4c!/b&bo=1QYoAgAAAAADN.s!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503112616511"></p><p>2.在web下</p><p><img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/tS3tY63exiZNUWwJevnZGtlezmDdhWGme3gam667CP78wQkDoBR3jAuMJ*WOLZqy9oU3lgPJFiFEMDZeDfxx4yf6HhbFM9MQy7z6BRSWSfE!/b&bo=8gHEAAAAAAADFwU!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503112733663"></p><p>3.文件夹功能</p><p><img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/tS3tY63exiZNUWwJevnZGv.8cdWLgthDyg8qNdBZTQbz57iv8f2n85rjmyrPLEsVebbO9JmveMMUjf7Xc57B9qy8VJGevJY*oHligk3WLJU!/b&bo=.QLjAgAAAAADJxg!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503112947032"></p><p><img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/tS3tY63exiZNUWwJevnZGi9AbFWsZqAnA0Ck3AgUljfwZ4xlwQlev8u8WeF9esUTizvN7j0Jc.EQKVqWNV90kIYNo634Gv5pN5J.Yef7wB4!/b&bo=wQT7AgAAAAADJz4!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503113202361"></p><h3 id="3-在idea中配置tomcat"><a href="#3-在idea中配置tomcat" class="headerlink" title="3.在idea中配置tomcat"></a>3.在idea中配置tomcat</h3><p>1.<strong>一般都在右上角</strong></p><p><img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/tS3tY63exiZNUWwJevnZGtN9DzrU3kviGa5HamquI7P9Qhw6qzgov2i6dZagrcT5mIQMSyvkvLQHG9pzelYnEM2VcrimQ6uC1jsW8myOfBQ!/b&bo=XgKEAAAAAAADF.o!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503113504440"></p><p>2.</p><p><img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/tS3tY63exiZNUWwJevnZGkB3PcH9nNVQ2XutACocE9KDSkcGEXtounuJx64SfscDVHEesRIQqUFqzg9jFFIF2BaSPSkCcvOzNR3UkO.D8HU!/b&bo=gwQBAwAAAAADN5c!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503113646612"></p><p>3.</p><p><img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/tS3tY63exiZNUWwJevnZGn9uVYEvGjIiHc1LUb6v7pUeUgs7tIqXdFVgxaI3K9ZivIWeO*2QhTAYpKNGfZavNUmA*.Yxv5JCiG6k.VGpvdE!/b&bo=QgTiAgAAAAADN7Q!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503113907378"></p><p>4.</p><p><img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/tS3tY63exiZNUWwJevnZGuT3.vBQfZwWvRsKUxH8q8zBmj5r3EdzJ4Yy7ZsOEOmwbUJMm0Y7HMf9Veup6cOlb5wAabJz81kURLK.rHHasMY!/b&bo=OgPdAgAAAAADJ.Q!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503120748401"></p><p>5.</p><p><img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/tS3tY63exiZNUWwJevnZGgaQbfYZfArvE8jHHBNObGUvDblMdyQS95RQyQylsMPRZJDq4v8q80KgOBc9zguivqbrj6Pal2SX9SvJSRBZ2fY!/b&bo=0wa1AQAAAAADN3M!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503120830624"></p><p>6.</p><p><img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/tS3tY63exiZNUWwJevnZGn49XJEG3RAWzexBVr2on8DlB7RiRQlFZefJOPJPRywr8UdvQ2svu53k2WVUSudIwcOJMPEsGFfrFIW*dj.ijkM!/b&bo=OgX9AQAAAAADJ8E!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503121022062"></p><h2 id="7-pom文件"><a href="#7-pom文件" class="headerlink" title="7.pom文件"></a>7.pom文件</h2><p><strong>在<dependencies>标签中添加依赖</dependencies></strong></p><p><img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/tS3tY63exiZNUWwJevnZGlZvrdb2AlD2.9Qm97WoKhsIwuA1sHqNC*DNpp.gSu4j5CDmcEG7ZXrAQqBBf0Yep0f24JNebBcW.x1LE0HXgMA!/b&bo=sgULAwAAAAADR90!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503160741086"> </p><h2 id="8-解决Maven资源导出失败问题"><a href="#8-解决Maven资源导出失败问题" class="headerlink" title="8.解决Maven资源导出失败问题"></a>8.解决Maven资源导出失败问题</h2><p><strong>maven由于约定大于配置</strong>，我们之后会遇到我们写的配置文件，无法被导出或者生效的问题，解决方案：</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--在build中配置resource，防止我们资源导出失败的问题。--&gt;</span><span class="hljs-comment">&lt;!-- directory：指定资源所在的目录，目录的路径是相对于pom.xml文件的。</span><span class="hljs-comment">     includes：指定要包含哪些文件。</span><span class="hljs-comment">     filtering标签中：false表示不过滤，true表示过滤。</span><span class="hljs-comment">--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span>                   <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>                   <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>               <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span>           <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span>                   <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>                   <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>               <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span>           <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre><h2 id="9-目录树"><a href="#9-目录树" class="headerlink" title="9.目录树"></a>9.目录树</h2><p><img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/tS3tY63exiZNUWwJevnZGsGViVL0cwhWABeBcWd7Mb494rzH2LGtXcmC2QAIC0YQlg6tJ7RKJUQXIC6SWbglGs*EDvSKhwqqdRzbNeAau1s!/b&bo=swOZAQAAAAADFxo!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503161240131"></p><p><img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/tS3tY63exiZNUWwJevnZGsQGbhI6XYh1TCfl9uiLX472raba94wzMaRVDYJBB41DCuKMcdQosEtjSRfS8toDudchNr8tiMSsYj9g8qftJrE!/b&bo=bwM6AwAAAAADF2c!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503161253149"></p><h2 id="10-Maven仓库"><a href="#10-Maven仓库" class="headerlink" title="10.Maven仓库"></a>10.Maven仓库</h2><ul><li>地址：<a href="https://mvnrepository.com/" target="_blank" rel="noopener">https://mvnrepository.com/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mvaen</title>
    <link href="/2020/05/26/JavaEE/Maven/"/>
    <url>/2020/05/26/JavaEE/Maven/</url>
    
    <content type="html"><![CDATA[<h1 id="Mvaen"><a href="#Mvaen" class="headerlink" title="Mvaen"></a>Mvaen</h1><h2 id="maven是什么【what】"><a href="#maven是什么【what】" class="headerlink" title="maven是什么【what】"></a>maven是什么【what】</h2><p><strong>① maven是一款服务于java平台的自动化构建工具</strong></p><p>make-&gt;Ant-&gt;Maven-&gt;Gradle</p><p>名字叫法：我们可以叫妹文也可以叫麦文，但是没有叫妈文的。</p><p><strong>② 构建</strong></p><p><strong>构建定义：把动态的Web工程经过编译得到的编译结果部署到服务器上的整个过程。</strong></p><p>编译：java源文件[.java]-&gt;编译-&gt;Class字节码文件[.class]</p><p>部署：最终在sevlet容器中部署的不是动态web工程，而是编译后的文件</p><p><strong>③ 构建的各个环节</strong></p><ul><li>清理clean：将以前编译得到的旧文件class字节码文件删除</li><li>编译compile：将java源程序编译成class字节码文件</li><li>测试test：自动测试，自动调用junit程序</li><li>报告report：测试程序执行的结果</li><li>打包package：动态Web工程打War包，java工程打jar包</li><li>安装install：Maven特定的概念—–将打包得到的文件复制到“仓库”中的指定位置</li><li>部署deploy：将动态Web工程生成的war包复制到Servlet容器下，使其可以运行</li></ul><h2 id="我为什么要学习这个技术"><a href="#我为什么要学习这个技术" class="headerlink" title="我为什么要学习这个技术?"></a>我为什么要学习这个技术?</h2><p><strong>① 一个项目就是一个工程</strong></p><p>如果项目非常庞大，就不适合使用package来划分模块，最好是每一个模块对应一个工程，利于分工协作。借助于maven就可以将一个项目拆分成多个工程</p><p><strong>② 项目中使用jar包，需要“复制”、“粘贴”项目的lib中</strong></p><p>同样的jar包重复的出现在不同的项目工程中，你需要做不停的复制粘贴的重复工作。借助于maven，可以将jar包保存在“仓库”中，不管在哪个项目只要使用引用即可就行。</p><p><strong>③ jar包需要的时候每次都要自己准备好或到官网下载</strong></p><p>借助于maven我们可以使用统一的规范方式下载jar包，规范</p><p><strong>④ jar包版本不一致的风险</strong></p><p>不同的项目在使用jar包的时候，有可能会导致各个项目的jar包版本不一致，导致未执行错误。借助于maven，所有的jar包都放在“仓库”中，所有的项目都使用仓库的一份jar包。</p><p><strong>⑤ 一个jar包依赖其他的jar包需要自己手动的加入到项目中</strong></p><p>FileUpload组件-&gt;IO组件，commons-fileupload-1.3.jar依赖于commons-io-2.0.1.jar</p><p>极大的浪费了我们导入包的时间成本，也极大的增加了学习成本。借助于maven，它会自动的将依赖的jar包导入进来。</p><h2 id="1Maven项目架构管理工具"><a href="#1Maven项目架构管理工具" class="headerlink" title="1Maven项目架构管理工具"></a>1Maven项目架构管理工具</h2><p>我们目前用来就是方便导入jar包的! .</p><p>Maven的核心思想:<strong>约定大于配置</strong></p><p>●有约束，不要去违反</p><h2 id="2-下载Maven"><a href="#2-下载Maven" class="headerlink" title="2.下载Maven"></a>2.下载Maven</h2><p><img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/ZOHqlMnlPhi5393oWyanhHqrZG7FpXGxC7sQr6R97OtH0bRhvMOD*xEV2nRbEpN5MAvzPD25oOqcpjVy1j2xxw!!/b&bo=CgXoAgAAAAADB8c!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503094338353"></p><h2 id="3-配置MAVEN的环境变量"><a href="#3-配置MAVEN的环境变量" class="headerlink" title="3.配置MAVEN的环境变量"></a>3.配置MAVEN的环境变量</h2><p>   在我们的系统环境变量中</p><ul><li><p>配置如下配置</p><pre><code class="hljs dos">创建M2_HOME      maven目录下的bin目录      创建MAVEN_HOME    maven的目录        在系统的<span class="hljs-built_in">path</span>中配置   <span class="hljs-variable">%MAVEN_HOMEN%</span>\bin</code></pre><ul><li>然后命令行查看maven版本  </li></ul><pre><code class="hljs applescript">mvn -<span class="hljs-built_in">version</span></code></pre></li><li><p>测试Maven是否安装成功</p></li></ul><h2 id="4-阿里云镜像"><a href="#4-阿里云镜像" class="headerlink" title="4.阿里云镜像"></a>4.阿里云镜像</h2><ul><li>镜像： mirrors</li></ul><p>​        作用：加速我们的下载</p><ul><li><p>国内建议使用阿里云的镜像</p></li><li><p>在Maven目录下的 conf/settings.xml中的<mirrors>标签添加如下代码</mirrors></p></li></ul><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span>    <span class="hljs-comment">&lt;!--This sends everything else to /public --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>*<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Nexus aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span></code></pre><h2 id="5-本地仓库"><a href="#5-本地仓库" class="headerlink" title="5.本地仓库"></a>5.本地仓库</h2><p>在本地仓库，远程仓库：</p><p><strong>建立一个本地仓库</strong>：Maven目录下的conf/ settings.xml中的<localRepository>标签添加如下代码</localRepository></p><ul><li>你要创建本地仓库的位置</li></ul><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>D:\Maven\apache-maven-3.6.3-bin\apache-maven-3.6.3\maven-repo<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span></code></pre><h2 id="6-在idea中使用maven"><a href="#6-在idea中使用maven" class="headerlink" title="6.在idea中使用maven"></a>6.在idea中使用maven</h2><h3 id="1-模板"><a href="#1-模板" class="headerlink" title="1.模板"></a>1.模板</h3><p>   1.启动IDEA</p><p>   2.创建一个MAVEN的项目</p><p>   3.<img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/tS3tY63exiZNUWwJevnZGpjkOvkl6TXRQ40rVIQWqndHCGFlJM24.b8cp5Bhi0760sIT*vmYHlDAAE*4G3xMQYUaCfxy*6eWiynvbLK1THM!/b&bo=IwQWAwAAAAADNyA!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503100325085"></p><p>4.<img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/ZOHqlMnlPhi5393oWyanhN5woCzJWlLEwBlIhpMvDiWxoSv*oIxLAN*c1CTxo5dygx5ufDvgAReTPb3d0bxb0A!!/b&bo=zQO*AAAAAAADB1M!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503100621755"></p><p>5.<img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/tS3tY63exiZNUWwJevnZGlx1fja9x7BSAPvEhKDeA5NzV3A6V*3OhIp19fuMltbbS0lAUBgc66G.IeeLNAmrQlTcZibAY0Peg.X3Qt67254!/b&bo=*AMVAgAAAAADJ.o!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503100746624"></p><p>6.<img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/tS3tY63exiZNUWwJevnZGvohyrN6y5xFw4w6B1nNIQV3bFEP3UeUB8dIDzurXv52iJ0uvEWqtZ8kd6QteFFK0H2UWQklOypXuLnx741A9EA!/b&bo=aQekAwAAAAADN9s!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503102709240"></p><p>7.<img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/tS3tY63exiZNUWwJevnZGsNGOnR4ZwHd1Tp6V0Cax7UVu9FuzPk7LAZ04gCKo1gR4Ga9fTCANaeJndprfqRlH5qJ4.j3Z0RywnALXGnPls8!/b&bo=AwTKAgAAAAADN90!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503111805878">  </p><p>8.</p><p><img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/tS3tY63exiZNUWwJevnZGqluifhDrveJkyhhr48ynLc7AzSf*WYDcIujlhCiNS6yVniyxka0*ycIparUgp8LOMdROw37TsnmMB.vk24Z698!/b&bo=EwTQAgAAAAADN9c!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503111945369"></p><h3 id="2-正常创建"><a href="#2-正常创建" class="headerlink" title="2.正常创建"></a>2.正常创建</h3><p><strong>不勾选内容，直接下一步</strong></p><p><img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/tS3tY63exiZNUWwJevnZGuXH3gyxcxGGTvx6TJjK6qSvtWod5KayNvS.iTPSrtHqWVZYdC2KY..WDuGD9ygaAZfhpIW00VlXYKugSOLyG4c!/b&bo=1QYoAgAAAAADN.s!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503112616511"></p><p>2.在web下</p><p><img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/tS3tY63exiZNUWwJevnZGtlezmDdhWGme3gam667CP78wQkDoBR3jAuMJ*WOLZqy9oU3lgPJFiFEMDZeDfxx4yf6HhbFM9MQy7z6BRSWSfE!/b&bo=8gHEAAAAAAADFwU!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503112733663"></p><p>3.文件夹功能</p><p><img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/tS3tY63exiZNUWwJevnZGv.8cdWLgthDyg8qNdBZTQbz57iv8f2n85rjmyrPLEsVebbO9JmveMMUjf7Xc57B9qy8VJGevJY*oHligk3WLJU!/b&bo=.QLjAgAAAAADJxg!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503112947032"></p><p><img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/tS3tY63exiZNUWwJevnZGi9AbFWsZqAnA0Ck3AgUljfwZ4xlwQlev8u8WeF9esUTizvN7j0Jc.EQKVqWNV90kIYNo634Gv5pN5J.Yef7wB4!/b&bo=wQT7AgAAAAADJz4!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503113202361"></p><h3 id="3-在idea中配置tomcat"><a href="#3-在idea中配置tomcat" class="headerlink" title="3.在idea中配置tomcat"></a>3.在idea中配置tomcat</h3><p>1.<strong>一般都在右上角</strong></p><p><img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/tS3tY63exiZNUWwJevnZGtN9DzrU3kviGa5HamquI7P9Qhw6qzgov2i6dZagrcT5mIQMSyvkvLQHG9pzelYnEM2VcrimQ6uC1jsW8myOfBQ!/b&bo=XgKEAAAAAAADF.o!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503113504440"></p><p>2.</p><p><img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/tS3tY63exiZNUWwJevnZGkB3PcH9nNVQ2XutACocE9KDSkcGEXtounuJx64SfscDVHEesRIQqUFqzg9jFFIF2BaSPSkCcvOzNR3UkO.D8HU!/b&bo=gwQBAwAAAAADN5c!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503113646612"></p><p>3.</p><p><img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/tS3tY63exiZNUWwJevnZGn9uVYEvGjIiHc1LUb6v7pUeUgs7tIqXdFVgxaI3K9ZivIWeO*2QhTAYpKNGfZavNUmA*.Yxv5JCiG6k.VGpvdE!/b&bo=QgTiAgAAAAADN7Q!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503113907378"></p><p>4.</p><p><img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/tS3tY63exiZNUWwJevnZGuT3.vBQfZwWvRsKUxH8q8zBmj5r3EdzJ4Yy7ZsOEOmwbUJMm0Y7HMf9Veup6cOlb5wAabJz81kURLK.rHHasMY!/b&bo=OgPdAgAAAAADJ.Q!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503120748401"></p><p>5.</p><p><img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/tS3tY63exiZNUWwJevnZGgaQbfYZfArvE8jHHBNObGUvDblMdyQS95RQyQylsMPRZJDq4v8q80KgOBc9zguivqbrj6Pal2SX9SvJSRBZ2fY!/b&bo=0wa1AQAAAAADN3M!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503120830624"></p><p>6.</p><p><img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/tS3tY63exiZNUWwJevnZGn49XJEG3RAWzexBVr2on8DlB7RiRQlFZefJOPJPRywr8UdvQ2svu53k2WVUSudIwcOJMPEsGFfrFIW*dj.ijkM!/b&bo=OgX9AQAAAAADJ8E!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503121022062"></p><h2 id="7-pom文件"><a href="#7-pom文件" class="headerlink" title="7.pom文件"></a>7.pom文件</h2><p><strong>在<dependencies>标签中添加依赖</dependencies></strong></p><p><img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/tS3tY63exiZNUWwJevnZGlZvrdb2AlD2.9Qm97WoKhsIwuA1sHqNC*DNpp.gSu4j5CDmcEG7ZXrAQqBBf0Yep0f24JNebBcW.x1LE0HXgMA!/b&bo=sgULAwAAAAADR90!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503160741086"> </p><h2 id="8-解决Maven资源导出失败问题"><a href="#8-解决Maven资源导出失败问题" class="headerlink" title="8.解决Maven资源导出失败问题"></a>8.解决Maven资源导出失败问题</h2><p><strong>maven由于约定大于配置</strong>，我们之后会遇到我们写的配置文件，无法被导出或者生效的问题，解决方案：</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--在build中配置resource，防止我们资源导出失败的问题。--&gt;</span><span class="hljs-comment">&lt;!-- directory：指定资源所在的目录，目录的路径是相对于pom.xml文件的。</span><span class="hljs-comment">     includes：指定要包含哪些文件。</span><span class="hljs-comment">     filtering标签中：false表示不过滤，true表示过滤。</span><span class="hljs-comment">--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span>                   <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>                   <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>               <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span>           <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span>                   <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>                   <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>               <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span>           <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre><h2 id="9-目录树"><a href="#9-目录树" class="headerlink" title="9.目录树"></a>9.目录树</h2><p><img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/tS3tY63exiZNUWwJevnZGsGViVL0cwhWABeBcWd7Mb494rzH2LGtXcmC2QAIC0YQlg6tJ7RKJUQXIC6SWbglGs*EDvSKhwqqdRzbNeAau1s!/b&bo=swOZAQAAAAADFxo!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503161240131"></p><p><img src="http://m.qpic.cn/psc?/V130TojW3qFRK7/tS3tY63exiZNUWwJevnZGsQGbhI6XYh1TCfl9uiLX472raba94wzMaRVDYJBB41DCuKMcdQosEtjSRfS8toDudchNr8tiMSsYj9g8qftJrE!/b&bo=bwM6AwAAAAADF2c!&rf=viewer_4" srcset="/img/loading.gif" alt="image-20200503161253149"></p><h2 id="10-Maven仓库"><a href="#10-Maven仓库" class="headerlink" title="10.Maven仓库"></a>10.Maven仓库</h2><ul><li>地址：<a href="https://mvnrepository.com/" target="_blank" rel="noopener">https://mvnrepository.com/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaEE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
